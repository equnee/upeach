"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const saber_utils_1 = require("saber-utils");
const chokidar_1 = __importDefault(require("chokidar"));
const saber_log_1 = require("saber-log");
const hash_sum_1 = __importDefault(require("hash-sum"));
const ID = 'builtin:source-pages';
const sourcePagesPlugin = {
    name: ID,
    apply(api) {
        api.hooks.beforeRun.tapPromise(ID, async () => {
            const pagesDir = api.resolveCwd('pages');
            const exts = api.transformers.supportedExtensions;
            const filePatterns = [
                `**/*.${exts.length === 1 ? exts[0] : `{${exts.join(',')}}`}`,
                '!**/{node_modules,dist,vendor}/**',
                '!**/_!(posts)/**'
            ];
            const files = await saber_utils_1.glob(filePatterns, {
                cwd: pagesDir,
                dot: false,
                stats: true
            }).then(files => Promise.all(files
                .sort((a, b) => (a.path > b.path ? 1 : -1))
                .map(async (file) => {
                saber_log_1.log.verbose(`Found page`, saber_log_1.colors.dim(file.path));
                const absolute = path_1.default.join(pagesDir, file.path);
                // eslint-disable-next-line require-atomic-updates
                const content = await saber_utils_1.fs.readFile(absolute, 'utf8');
                return {
                    relative: file.path,
                    absolute,
                    content,
                    mtime: file.stats && file.stats.mtime,
                    birthtime: file.stats && file.stats.birthtime
                };
            })));
            api.hooks.manipulatePage.tapPromise('manipulate-page', async ({ action, id, page }) => {
                // Remove all child pages
                api.pages.removeWhere(page => Boolean(page.internal.parent));
                if (action === 'remove') {
                    // Remove itself
                    api.pages.removeWhere(page => {
                        return page.internal.id === id;
                    });
                }
                else if (action) {
                    api.pages.createPage(page);
                    await api.hooks.onCreatePage.promise(page);
                }
            });
            // Write all pages
            // This is triggered by all file actions: change, add, remove
            api.hooks.emitPages.tapPromise('pages', async () => {
                const pages = [...api.pages.values()];
                saber_log_1.log.verbose('Emitting pages');
                // TODO: maybe write pages with limited concurrency?
                await Promise.all(pages.map(async (page) => {
                    if (page.internal.saved)
                        return;
                    const newContentHash = hash_sum_1.default(page);
                    const outPath = api.resolveCache('pages', `${page.internal.id}.saberpage`);
                    // TODO: is there any better solution to checking if we need to write the page?
                    const exists = await saber_utils_1.fs.pathExists(outPath);
                    if (exists) {
                        const contentHash = await saber_utils_1.fs.readFile(outPath, 'utf8');
                        if (contentHash === newContentHash) {
                            // Skip if content doesn't change
                            return;
                        }
                    }
                    saber_log_1.log.verbose(`Emitting page ${outPath}`);
                    await saber_utils_1.fs.outputFile(outPath, newContentHash, 'utf8');
                    // eslint-disable-next-line require-atomic-updates
                    page.internal.saved = true;
                }));
            });
            await api.hooks.initPages.promise();
            await Promise.all(files.map(async (file) => {
                const page = api.pages.fileToPage(file);
                api.pages.createPage(page);
                await api.hooks.onCreatePage.promise(page);
            }));
            await api.hooks.onCreatePages.promise();
            await api.hooks.emitPages.promise();
            if (api.dev) {
                const watcher = chokidar_1.default.watch(filePatterns, {
                    cwd: pagesDir,
                    ignoreInitial: true
                });
                const handler = (type) => async (filename) => {
                    const filepath = path_1.default.join(pagesDir, filename);
                    if (type === 'remove') {
                        await api.hooks.manipulatePage.promise({
                            action: 'remove',
                            id: hash_sum_1.default(filepath)
                        });
                    }
                    else {
                        const stat = await saber_utils_1.fs.stat(filepath);
                        const file = {
                            absolute: filepath,
                            relative: filename,
                            birthtime: stat.birthtime,
                            mtime: stat.mtime,
                            content: await saber_utils_1.fs.readFile(filepath, 'utf8')
                        };
                        const page = api.pages.fileToPage(file);
                        await api.hooks.manipulatePage.promise({ action: 'create', page });
                    }
                    await api.hooks.onCreatePages.promise();
                    await api.hooks.emitPages.promise();
                    await api.hooks.emitRoutes.promise();
                };
                watcher.on('add', (filename) => {
                    handler('add')(filename);
                });
                watcher.on('unlink', (filename) => {
                    handler('remove')(filename);
                });
                watcher.on('change', (filename) => {
                    handler('change')(filename);
                });
            }
        });
    }
};
exports.default = sourcePagesPlugin;
