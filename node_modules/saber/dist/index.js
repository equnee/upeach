"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="../declarations.d.ts" />
const path_1 = __importDefault(require("path"));
const http_1 = __importDefault(require("http"));
const saber_utils_1 = require("saber-utils");
const saber_log_1 = require("saber-log");
const resolve_from_1 = __importDefault(require("resolve-from"));
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const get_port_1 = __importDefault(require("get-port"));
const Pages_1 = require("./Pages");
const BrowserApi_1 = require("./BrowserApi");
const Transformers_1 = require("./Transformers");
const configLoader_1 = __importDefault(require("./utils/configLoader"));
const resolvePackage_1 = __importDefault(require("./utils/resolvePackage"));
const plugins_1 = __importDefault(require("./plugins"));
const Compiler_1 = require("./Compiler");
const WebpackUtils_1 = require("./WebpackUtils");
const hooks_1 = require("./hooks");
const vue_renderer_1 = require("./vue-renderer");
const validateConfig_1 = require("./utils/validateConfig");
class Saber {
    constructor(opts = {}, config = {}) {
        this.opts = Object.assign(Object.assign({}, opts), { cwd: path_1.default.resolve(opts.cwd || '.') });
        this.initialConfig = config;
        this.pages = new Pages_1.Pages(this);
        this.browserApi = new BrowserApi_1.BrowserApi(this);
        this.webpackUtils = new WebpackUtils_1.WebpackUtils(this);
        this.log = saber_log_1.log;
        this.colors = saber_log_1.colors;
        this.utils = require('saber-utils');
        this.hooks = hooks_1.hooks;
        this.transformers = new Transformers_1.Transformers();
        this.runtimePolyfills = new Set();
        this.compilers = {
            server: new Compiler_1.Compiler('server', this),
            client: new Compiler_1.Compiler('client', this)
        };
        const hookNames = Object.keys(this.hooks);
        for (const hook of hookNames) {
            const ignoreNames = ['theme-node-api', 'user-node-api'];
            this.hooks[hook].intercept({
                register(tapInfo) {
                    const { fn, name } = tapInfo;
                    tapInfo.fn = (...args) => {
                        if (!ignoreNames.includes(name)) {
                            const msg = `${hook} ${saber_log_1.colors.dim(`(${name})`)}`;
                            saber_log_1.log.verbose(msg);
                        }
                        return fn(...args);
                    };
                    return tapInfo;
                }
            });
        }
        if (opts.verbose) {
            process.env.SABER_LOG_LEVEL = '4';
        }
        // Load package.json data
        const loadedPkg = configLoader_1.default.load({
            files: ['package.json'],
            cwd: this.opts.cwd
        });
        this.pkg = Object.assign(Object.assign({}, loadedPkg), { data: loadedPkg.data || {} });
        // To make TypeScript happy
        // We actually initialize them in `prepare()`
        // TODO: find a better way
        this.configDir = '';
        this.configPath = '';
        // Load Saber config
        const loadedConfig = this.loadConfig();
        this.config = loadedConfig.config;
        this.configPath = loadedConfig.configPath;
        this.configDir = this.configPath && path_1.default.dirname(this.configPath);
        if (this.configPath) {
            saber_log_1.log.info(`Using config file: ${saber_log_1.colors.dim(path_1.default.relative(process.cwd(), this.configPath))}`);
        }
        this.renderer = new vue_renderer_1.VueRenderer();
        this.renderer.init(this);
        // Load theme
        if (this.config.theme) {
            this.theme = resolvePackage_1.default(this.config.theme, {
                cwd: this.configDir || this.opts.cwd,
                prefix: 'saber-theme-'
            });
            // When a theme is loaded from `node_modules` and `$theme/dist` directory exists
            // We use the `dist` directory instead
            if (this.theme.includes('node_modules')) {
                const distDir = path_1.default.join(this.theme, 'dist');
                if (saber_utils_1.fs.existsSync(distDir)) {
                    this.theme = distDir;
                }
            }
            saber_log_1.log.info(`Using theme: ${saber_log_1.colors.dim(this.config.theme)}`);
            saber_log_1.log.verbose(() => `Theme directory: ${saber_log_1.colors.dim(this.theme)}`);
        }
        else {
            this.theme = this.renderer.defaultTheme;
        }
    }
    loadConfig(configFiles = configLoader_1.default.CONFIG_FILES) {
        const { data, path: configPath } = configLoader_1.default.load({
            files: configFiles,
            cwd: this.opts.cwd
        });
        return {
            config: validateConfig_1.validateConfig(lodash_merge_1.default({}, data, this.initialConfig), {
                dev: this.dev
            }),
            configPath
        };
    }
    setConfig(config, configPath) {
        this.config = config;
        this.configPath = configPath;
        this.configDir = configPath && path_1.default.dirname(configPath);
    }
    get dev() {
        return Boolean(this.opts.dev);
    }
    get lazy() {
        return this.dev && this.config.build.lazy;
    }
    async prepare() {
        // Load built-in plugins
        for (const plugin of plugins_1.default) {
            const resolvedPlugin = require(plugin.resolve);
            await this.applyPlugin(resolvedPlugin.default || resolvedPlugin);
        }
        // Load user plugins
        await this.hooks.beforePlugins.promise();
        const userPlugins = this.getUserPlugins();
        if (userPlugins.length > 0) {
            saber_log_1.log.info(`Using ${userPlugins.length} plugin${userPlugins.length > 1 ? 's' : ''} from config file`);
        }
        for (const plugin of userPlugins) {
            await this.applyPlugin(plugin, plugin.options, plugin.location);
        }
        await this.hooks.afterPlugins.promise();
    }
    async applyPlugin(plugin, options, pluginLocation) {
        await plugin.apply(this, options);
        if (!plugin.name.startsWith('builtin:')) {
            saber_log_1.log.verbose(() => `Using plugin "${saber_log_1.colors.bold(plugin.name)}" ${pluginLocation ? saber_log_1.colors.dim(pluginLocation) : ''}`);
        }
    }
    getUserPlugins() {
        // Plugins that are specified in user config, a.k.a. saber-config.js etc
        const plugins = this.configDir && this.config.plugins
            ? this.config.plugins.map(p => {
                if (typeof p === 'string') {
                    p = { resolve: p };
                }
                const location = resolve_from_1.default(this.configDir, p.resolve);
                const resolvedPlugin = Object.assign(Object.assign({}, require(location)), { location, options: p.options });
                return resolvedPlugin;
            })
            : [];
        const applyFilterPlugins = (plugins) => {
            const handlers = new Set();
            for (const plugin of plugins) {
                const { filterPlugins, options } = plugin;
                if (filterPlugins) {
                    delete plugin.filterPlugins;
                    handlers.add(plugins => filterPlugins(plugins, options));
                }
            }
            if (handlers.size > 0) {
                for (const handler of handlers) {
                    plugins = handler(plugins);
                }
                return applyFilterPlugins(plugins);
            }
            return plugins;
        };
        return applyFilterPlugins(this.hooks.filterPlugins.call(plugins));
    }
    resolveCache(...args) {
        return this.resolveCwd('.saber', ...args);
    }
    resolveCwd(...args) {
        return path_1.default.resolve(this.opts.cwd, ...args);
    }
    resolveOwnDir(...args) {
        return path_1.default.join(__dirname, '../', ...args);
    }
    resolveOutDir(...args) {
        return this.resolveCwd(this.config.build.outDir, ...args);
    }
    getWebpackConfig(opts) {
        opts = Object.assign({ type: 'client' }, opts);
        const chain = require('./webpack/webpack.config')(this, opts);
        this.hooks.chainWebpack.call(chain, opts);
        const config = this.hooks.getWebpackConfig.call(chain.toConfig(), opts);
        if (this.opts.inspectWebpack) {
            require('./utils/inspectWebpack')(config, opts.type);
        }
        return config;
    }
    async run() {
        // Throw an error if both `public` and `.saber/public` exist
        // Because they are replaced by `static` and `public`
        // TODO: remove this error before v1.0
        const hasOldPublicFolder = await Promise.all([
            saber_utils_1.fs.pathExists(this.resolveCache('public')),
            saber_utils_1.fs.pathExists(this.resolveCwd('public')),
            saber_utils_1.fs.pathExists(this.resolveCwd('public/index.html'))
        ]).then(([hasOldOutDir, hasPublicDir, hasNewPublicDir]) => hasOldOutDir && hasPublicDir && !hasNewPublicDir);
        if (hasOldPublicFolder) {
            // Prevent from deleting public folder
            throw new Error([
                `It seems you are using the ${saber_log_1.colors.underline(saber_log_1.colors.cyan('public'))} folder to store static files,`,
                ` this behavior has changed and now we use ${saber_log_1.colors.underline(saber_log_1.colors.cyan('static'))} folder for static files`,
                ` while ${saber_log_1.colors.underline(saber_log_1.colors.cyan('public'))} folder is used to output generated files,`,
                ` to prevent from unexpectedly deleting your ${saber_log_1.colors.underline(saber_log_1.colors.cyan('public'))} folder, please rename it to ${saber_log_1.colors.underline(saber_log_1.colors.cyan('static'))} and delete ${saber_log_1.colors.underline(saber_log_1.colors.cyan('.saber/public'))} folder as well`
            ].join(''));
        }
        await this.hooks.beforeRun.promise();
        await this.hooks.emitRoutes.promise();
    }
    // Build app in production mode
    async build(options = {}) {
        const { skipCompilation } = options;
        await this.prepare();
        await this.run();
        if (!skipCompilation) {
            await this.renderer.build();
            await this.hooks.afterBuild.promise();
        }
        await this.renderer.generate();
        await this.hooks.afterGenerate.promise();
    }
    async serve() {
        await this.prepare();
        await this.run();
        const server = http_1.default.createServer(this.renderer.getRequestHandler());
        // Make sure the port is available
        const { host, port = 3000 } = this.config.server;
        this.actualServerPort = await get_port_1.default({
            port: get_port_1.default.makeRange(port, port + 1000),
            host
        });
        server.listen(this.actualServerPort, host);
    }
    async serveOutDir() {
        await this.prepare();
        return require('./utils/serveDir')({
            dir: this.resolveOutDir(),
            host: this.config.server.host,
            port: this.config.server.port
        });
    }
    hasDependency(name) {
        return this.getDependencies().includes(name);
    }
    getDependencies() {
        return [
            ...Object.keys(this.pkg.data.dependencies || {}),
            ...Object.keys(this.pkg.data.devDependencies || {})
        ];
    }
    localResolve(name) {
        return require('resolve-from').silent(this.opts.cwd, name);
    }
    localRequire(name) {
        const resolved = this.localResolve(name);
        return resolved && require(resolved);
    }
}
exports.Saber = Saber;
exports.createSaber = (opts, config) => new Saber(opts, config);
