"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const hash_sum_1 = __importDefault(require("hash-sum"));
const saber_utils_1 = require("saber-utils");
const saber_log_1 = require("saber-log");
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const getPermalink_1 = __importDefault(require("./utils/getPermalink"));
const getPageType_1 = __importDefault(require("./utils/getPageType"));
const assetsAttribute_1 = require("./utils/assetsAttribute");
// A regex parsing RFC3339 date followed by {_,-}, and ended by some characters
const FILE_NAME_REGEXP = /^(((\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])(T([01]\d|2[0-3]):([0-5]\d):([0-5]\d|60)(\.\d+)?(Z|(\+|-)([01]\d|2[0-3]):([0-5]\d)))?)(_|-))?(.+$)/;
class Pages extends Map {
    constructor(api) {
        super();
        this.api = api;
        this.redirectRoutes = new Map();
    }
    normalizePage(_page) {
        const { api } = this;
        const page = lodash_merge_1.default({
            type: 'page',
            internal: {},
            contentType: 'default'
        }, _page);
        let transformer = api.transformers.get(page.contentType);
        if (!transformer) {
            saber_log_1.log.warn(`No transformer was found for content type: ${page.contentType}`);
            transformer = api.transformers.get('default');
        }
        // Transform page
        if (transformer.transform) {
            transformer.transform(page);
        }
        // These fields are computed from other fields
        // And transformers can update the `page`
        // So we set them after applying the transformer
        // Hexo compatibility
        if (page.date) {
            page.createdAt = page.date;
        }
        if (page.updated) {
            page.updatedAt = page.updated;
        }
        // Ensure date format
        if (typeof page.createdAt === 'string') {
            page.createdAt = new Date(page.createdAt);
        }
        if (typeof page.updatedAt === 'string') {
            page.updatedAt = new Date(page.updatedAt);
        }
        if (!page.permalink && page.slug) {
            page.permalink = getPermalink_1.default(Object.keys(api.config.locales || {})
                .map(p => p.slice(1))
                .filter(Boolean), { slug: page.slug, type: page.type, createdAt: page.createdAt }, typeof api.config.permalinks === 'function'
                ? api.config.permalinks(page)
                : api.config.permalinks);
        }
        if (!page.internal || !page.internal.id) {
            throw new Error(`Page must have an internal id.`);
        }
        page.assets = page.assets
            ? assetsAttribute_1.prefixAssets(page.assets, page.internal.absolute
                ? path_1.default.dirname(page.internal.absolute)
                : api.opts.cwd)
            : {};
        // Ensure this page is not saved
        // So that it will be emitted to disk later in `emitPages` hook
        page.internal.saved = false;
        // Backward compatible
        // TODO: remove in 1.0
        page.attributes = page;
        return page;
    }
    fileToPage(file) {
        const relativePath = saber_utils_1.slash(file.relative);
        const absolutePath = saber_utils_1.slash(file.absolute);
        const parsedFileName = FILE_NAME_REGEXP.exec(relativePath
            // Remove leading _posts/
            .replace(/^_posts\//, '')
            // Remove extension
            .replace(/\.[a-z]+$/i, '')); // It could never be `null`
        const slug = parsedFileName[16];
        const pageInput = {
            slug,
            type: getPageType_1.default(saber_utils_1.slash(file.relative)),
            internal: {
                id: hash_sum_1.default(file.absolute),
                absolute: absolutePath,
                relative: relativePath,
                isFile: true
            },
            contentType: this.api.transformers.getContentTypeByExtension(path_1.default.extname(relativePath).slice(1)),
            content: file.content,
            createdAt: parsedFileName[2] || file.birthtime,
            updatedAt: file.mtime
        };
        return pageInput;
    }
    createPage(pageInput) {
        const page = this.normalizePage(pageInput);
        this.set(page.internal.id, page);
    }
    removePage(id) {
        this.removeWhere(page => {
            return page.internal.id === id;
        });
    }
    removeWhere(getCondition) {
        for (const page of this.values()) {
            const condition = getCondition(page);
            if (condition) {
                this.delete(page.internal.id);
            }
        }
    }
    getPagePublicFields(page) {
        let result = typeof page === 'string' ? this.get(page) : page;
        if (!result) {
            throw new Error(`The page doesn't exist`);
        }
        result = Object.assign({}, result, {
            content: undefined,
            internal: undefined
        });
        // TODO: remove in 1.0
        result.attributes = result;
        return result;
    }
    createRedirect(_configs) {
        if (_configs) {
            const configs = Array.isArray(_configs) ? _configs : [_configs];
            for (const config of configs) {
                this.redirectRoutes.set(config.fromPath, config);
            }
        }
    }
    getMatchedLocalePath(permalink) {
        const localePaths = Object.keys(this.api.config.locales || {}).filter(p => p !== '/');
        for (const localePath of localePaths) {
            if (localePath === permalink || permalink.startsWith(localePath)) {
                return localePath;
            }
        }
        return '/';
    }
}
exports.Pages = Pages;
